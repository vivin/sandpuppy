#!/usr/bin/perl

use warnings FATAL => 'all';
use strict;
use Parallel::ForkManager;

  # TODO: you will need to support being able to specify a particular readpng that can generate traces.
  # TODO: basically you want to run readpng against inputs generated by different fuzzers so that you
  # TODO: get the output. this script right now, is basically just redoing what afl-fuzz would have done
  # TODO: for a particular waypoint/domain.
  #
  # TODO: and the file name can be confusing. because let's say you are running readpng with heap domain
  # TODO: against the inputs in the queue directory generated for libpng-plain, then the trace files
  # TODO: cannot simply be <input>.trace. it would need to be <input>-<readpng-domain>.trace.
  # TODO: so i guess you basically need to parameterize the runner itself. basically so that you can 
  # TODO: generate traces from inputs not necessarily generated by the fuzzing using that domain. you
  # TODO: need this especially when you consider that the traces generated by heap, heap2, and heap3
  # TODO: are different and you may even be generating traces with return values and parameters.
  # TODO: another thing that makes it clear these two concerns are different is that you would never
  # TODO: really run the plain readpng against anything since that won't generate traces. so the point
  # TODO: here is to distinguish between tracing and fuzzing. not every domain that you implement will
  # TODO: necessarily generate a trace.

  # TODO: !!!! forget all that nonsense. how about you ALWAYS append the tracing waypoint to the trace
  # TODO: !!!! file?? that makes it less ambiguous. you don't have to memorize the additional semantic
  # TODO: !!!! of "if the waypoint is missing, it means it was generated when it was actually fuzzed"
  # TODO: !!!! also, absent the enclosing context of the results directory in which the trace file
  # TODO: !!!! exists, you won't know what tracing waypoint generated the trace. make this change to
  # TODO: !!!! afl-fuzz.c too. ooh one better. let's include both waypoint and tracing waypoint. so
  # TODO: !!!! yes it becomes redundant in afl-fuzz.c but otherwise it tells us the fuzzer that
  # TODO: !!!! generated the input and the tracing domain that generated the trace in the case where
  # TODO: !!!! we run a tracing domain instrumented binary against inputs generated by another domain.

  my $versions = ["1.5.9", "1.6.15"];
  my $waypoints = ["plain", "heap", "heap2", "heap3"];
  my $input_types = ["queue", "hangs", "crashes"];

  my $inputs = [];

  foreach my $version (@{$versions}) {
    foreach my $waypoint(@{$waypoints}) {
      foreach my $input_type (@{$input_types}) {
        chomp(my @find = `find results/$version-$waypoint/$input_type -type f | grep -v "\\.state" | sort`);

        foreach my $file(@find) {
          push @{$inputs}, {
            "waypoint" => $waypoint,
            "version" => $version,
            "input_type" => $input_type,
            "input_file" => $file
          };
        }
      }
    }
  }

  my $manager = Parallel::ForkManager->new(32);

  $manager->run_on_finish(sub {
    my ($pid, $exit_code, $input) = @_;

    my $version = $input->{version};
    my $waypoint = $input->{waypoint};
    my $input_file = $input->{input_file};

    print "$pid: generated trace for version $version using readpng(trace) against $waypoint fuzzer input: $input_file\n";

    my $trace_directory = "results/traces";
    my $trace_file = "$trace_directory/pid-$pid.trace";
    my $new_trace_file = "$input_file.trace";

    system "cp $trace_file $new_trace_file";
    system("rm $trace_file");
  });

  foreach my $input (@{$inputs}) {
    $manager->start($input) and next;

    my $version = $input->{version};
    my $input_file = $input->{input_file};
    my $readpng = "libpng-$version-trace/contrib/libtests/readpng";

    open(STDOUT, "/dev/null");
    open(STDERR, "/dev/null");
    open(STDIN, $input_file);

    exec($readpng) or die("exec: $!");
    # $manager->finish; is not necessary because exec never returns
  }

  $manager->wait_all_children;

